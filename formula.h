#pragma once
#include <array>
#include <cassert>
#include <map>

#include "MiniSat-p_v1.14/Solver.h"
#include "aag.h"

struct Formula {
	static constexpr char And = '&', Or = '|';

	virtual ~Formula();

	// String returns the Formula nicely formatted as std::string.
	virtual auto String() const -> std::string;

	// Free deallocates the memory used by a Formula. Use this to destroy the whole structure.
	virtual auto Free() -> void;

	// Invert negates the Formula, but tries to push the negation inward as much as possible
	// by repeatedly applying De Morgans laws.
	virtual auto Invert() -> Formula *;

	// Copy performs a deep copy of a Formula.
	virtual auto Copy() const -> Formula *;

	// FromAIG infers the Formula for a particular variable of an AIG struct.
	static auto FromAIG(const AIG &, int var) -> Formula *;

	// Unwind unwinds the Latch-es inside the Formula one step further.
	static auto Unwind(const AIG &, Formula *f) -> void;

	// TseitinTransform returns a std::vector of Formulas which are the individual clauses
	// of the CNF generated by performing Tseitin's Transformation. The function does not
	// modify the original Formula. firstLit must be a literal that is not present in the
	// Formula.
	static auto TseitinTransform(const Formula *f, int firstLit) -> std::vector<Formula *>;

	// RemoveLatches removes all Latch-es from a Formula. If the Latch in question was never
	// unwound, it is replaced with False. Otherwise, it is replaced by the expression it
	// was unwound into. It does not modify the original Formula but returns a copy of it
	// with the latches removed which must be destroyed when it is not needed anymore.
	static auto RemoveLatches(Formula *f) -> Formula *;

	// Concat concatenates two formulas with an operator. The default value for op is And.
	static auto Concat(Formula*, Formula*, char op = And) -> Formula *;

	// SimplifyNegations removes double negations and negations of True and False.
	static auto SimplifyNegations(Formula *f) -> Formula*;

	// ToSolver adds CNF clauses to a miniSAT Solver.
	static auto ToSolver(Solver &s, const std::vector<Formula *> &ff_) -> std::map<int,int>;

	// InvertOp returns Or when op is And and And if op is Or.
	// The function throws a std::domain_error if op is neither And nor Or.
	static constexpr auto InvertOp(char op) -> char {
		return (op == And || op == Or) ? (op == And ? Or : And) : throw std::domain_error("operator is neither And nor Or");
	}
};

struct True : Formula {
	virtual auto String() const -> std::string;
	virtual auto Free() -> void;
	virtual auto Invert() -> Formula *;
	virtual auto Copy() const -> Formula *;
};

struct False : Formula {
	virtual auto String() const -> std::string;
	virtual auto Free() -> void;
	virtual auto Invert() -> Formula *;
	virtual auto Copy() const -> Formula *;
};

extern True TrueVal;
extern False FalseVal;

struct FormulaVar : Formula {
	int var;

	explicit FormulaVar(int var);
	virtual auto String() const -> std::string;
	virtual auto Free() -> void;
	virtual auto Invert() -> Formula *;
	virtual auto Copy() const -> Formula *;
};

struct BinaryOp : Formula {
	std::array<Formula *, 2> ff;
	char op;

	explicit BinaryOp(char op);
	BinaryOp(char op, Formula *, Formula *);
	virtual auto String() const -> std::string;
	virtual auto Free() -> void;
	virtual auto Invert() -> Formula *;
	virtual auto Copy() const -> Formula *;
};

struct Negate : Formula {
	Formula *f;

	explicit Negate(Formula *);
	virtual auto String() const -> std::string;
	virtual auto Free() -> void;
	virtual auto Invert() -> Formula *;
	virtual auto Copy() const -> Formula *;
};

struct Latch : Formula {
	int q, nextQ;
	Formula *f;

	Latch(int q, int nextQ);
	virtual auto String() const -> std::string;
	virtual auto Free() -> void;
	virtual auto Invert() -> Formula *;
	virtual auto Copy() const -> Formula *;
};
